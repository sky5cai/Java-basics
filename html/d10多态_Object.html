<!DOCTYPE html>
<html>
<head>
<title>MarkdownPad Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
</head>
<body>
<h1 id="d10-_object">d10多态_Object</h1>
<h2 id="-">导语：</h2>
<blockquote>
<p>想到在写</p>
</blockquote>
<p><a name="top"/></p>
<ol>
<li><a href="#DuoTaiDemo">引出了多态的好处。通过动物示例发现操作父类型可以提高扩展性</a></li><li><a href="#DuoTaiDemo2">动物的示例，了解了多态的体现，好处，弊端，前提，向上向下转型，以及什么时候用？★★★★★</a></li><li><a href="#DuoTaiTest">毕老师和毕姥爷的故事。将多态的知识点串一下。自动动手写！★★★★★</a></li><li><a href="#DuoTaiTest2">分三个阶段 完成笔记本电脑使用外围设备。并通过接口解耦，并通过多态提高程序的扩展性。★★★★★★★</a></li><li><a href="#DuoTaiDemo3">多态调用时，成员变量，成员函数，静态函数的特点。以及规律</a></li><li><a href="#DuoTaiTest3"> 一定要画图，得出结果。有点难！没视频，★★★★★</a></li><li><a href="#ObjectDemo">了解Object类中的equals toString方法的使用</a></li></ol>
<h2 id="1-top-a-name-duotaidemo-">1. <a href="#top">引出了多态的好处。通过动物示例发现操作父类型可以提高扩展性</a><a name="DuoTaiDemo"/></h2>
<pre><code>
//多态技术的引出。解决什么问题？程序扩展性的问题。

//描述Dog
class Dog extends Animal 
{
    public void eat()
    {
        System.out.println(&quot;骨头&quot;);
    }
    public void lookHome()
    {
        System.out.println(&quot;看家&quot;);
    }
}

//描述猫
class Cat extends Animal 
{
    public void eat()
    {
        System.out.println(&quot;鱼&quot;);
    }
    public void catchMouse()
    {
        System.out.println(&quot;抓老鼠&quot;);
    }
}
//进行抽取。将共性的功能抽取到父类Animal中。
abstract class Animal
{
    public abstract void eat();
}



class DuoTaiDemo
{
    public static void main(String[] args) 
    {
        Dog d = new Dog();
//        d.eat();
        method(d);

        Cat c = new Cat();
        method(c);
    }
    /*
    发现，每多一个动物，都需要为这个动物单独定义一个功能，
    让这个动物的对象去做事。
    这个程序扩展性就很差。
    如何提高这个扩展性呢？
    发现既然是让动作去eat，无论是dog，还是cat,
    eat是它们共性，干脆，将eat进行抽取。抽取到父类Animal中。

    Dog是Animal中的一种。
    Dog d = new Dog();
    Animal a = new Dog();
    Cat c = new Cat();
    Animal aa = new Cat();
    */
    //只要建立animal的引用就可以接收所有的dog cat对象进来。让它们去eat。
    //提高了程序的扩展性。
    public static void method(Animal a)
    {
        a.eat();
    }

    /*
    //接收Dog，让dog做事。
    public static void method(Dog d)
    {
        d.eat();
    }
    //接收Cat，让cat做事。
    public static void method(Cat c)
    {
        c.eat();
    }
    */

}
</code></pre><h2 id="2-top-a-name-duotaidemo2-">2. <a href="#top">动物的示例，了解了多态的体现，好处，弊端，前提，向上向下转型，以及什么时候用？★★★★★</a><a name="DuoTaiDemo2"/></h2>
<pre><code>
//多态

class Dog extends Animal 
{
    public void eat()
    {
        System.out.println(&quot;骨头&quot;);
    }
    public void lookHome()
    {
        System.out.println(&quot;看家&quot;);
    }
}

//描述猫
class Cat extends Animal 
{
    public void eat()
    {
        System.out.println(&quot;鱼&quot;);
    }
    public void catchMouse()
    {
        System.out.println(&quot;抓老鼠&quot;);
    }
}
//进行抽取。将共性的功能抽取到父类Animal中。
abstract class Animal
{
    public abstract void eat();
}

/*
多态：
    【体现】
        父类的引用或者接口的引用指向了自己的子类对象。
        Dog d = new Dog();//Dog对象的类型是Dog类型。
        Animal a = new Dog();//Dog对象的类型右边是Dog类型，左边Animal类型。
    【好处】
        提高了程序的扩展性。
    【弊端】
        通过父类引用操作子类对象时，只能使用父类中已有的方法，不能操作子类特有的方法。
    【前提】
        1，必须有关系：继承，实现。
        2，通常都有重写操作。
    【子类的特有方法如何调用呢？】
    Animal a = new Dog();//Animal是父类型，new Dog()是子对象。
    但是父类型引用指向子类对象时，这就是让子类对象进行了类型的提升(向上转型)。
    向上转型好处：提高了扩展性，隐藏了子类型。弊端：不能使用子类型的特有方法。
    如果要想使用子类的特有方法，只有子类型可以用。
    可以向下转型，强制转换。
    Animal a = new Dog();
    a.eat();
    Dog d = (Dog)a;//将a转型为Dog类型。向下转型。
    d.lookHome();
    向下转型什么时候用？当需要使用子类型的特有内容时。

    注意：无论向上还是向下转型，最终都是子类对象做着类型的变化。

    【向下转型的注意事项】
    Animal a = new Dog();
    //Cat c = (Cat)a;向下转型因为不明确具体子类对象类型，所以容易引发ClassCastException异常。
    所以为了避免这个问题，需要在向下转型前，做类型的判断。
    判断类型用的是关键字 instanceof
    if(a instanceof Cat)//a指向的对象的类型是Cat类型。
    {
        //将a转型Cat类型。
        Cat c = (Cat)a;
        c.catchMouse();
    }
    else if(a instanceof Dog)
    {
        Dog d = (Dog)a;
        d.lookHome();
    }

    【转型总结】
    1，什么时候使用向上转型呢？
        提高程序的扩展性，不关系子类型(子类型被隐藏)。
        需要用子类的特有方法吗？不需要，哦了。向上转型。
    2，什么时候使用向下转型呢？
        需要使用子类型的特有方法时。
        但是一定要使用 instanceof 进行类型的判断。避免发生 ClassCastException

*/

class DuoTaiDemo2
{
    public static void main(String[] args) 
    {
        Dog d = new Dog();
//        d.eat();
//        d.lookHome();

        /*
        Animal a = new Dog();
        a.eat();//可以的。
//        a.lookHome();//不可以的。
        */

        method(d);
        Cat c = new Cat();
        method(c);
    }
    public static void method(Animal a)
    {

        a.eat();
//        Dog d = (Dog)a;//ClassCastException:类型转换异常。
//        d.lookHome();

//        a.lookHome();//不可以，因为动物不具备这个功能。
    }

}
</code></pre><h2 id="3-top-a-name-duotaitest-">3. <a href="#top">毕老师和毕姥爷的故事。将多态的知识点串一下。自动动手写！★★★★★</a><a name="DuoTaiTest"/></h2>
<pre><code>
class 毕姥爷
{
    public void 讲课()
    {
        System.out.println(&quot;讲管理&quot;);
    }
    public void 钓鱼()
    {
        System.out.println(&quot;钓鱼&quot;);
    }
}

class 毕老师 extends 毕姥爷
{
    public void 讲课()
    {
        System.out.println(&quot;Java&quot;);
    }
    public void 看电影()
    {
        System.out.println(&quot;看电影&quot;);
    }
}


class DuoTaiTest 
{
    public static void main(String[] args) 
    {
        毕姥爷 x = new 毕老师();//多态，向上转型。
        x.讲课();
        x.钓鱼();
//        x.看电影();//不行。
        //想要使用毕老师的特有方法时，需要向下转型。
        if(x instanceof 毕老师)
        {
            毕老师 y = (毕老师)x;
            y.看电影();
        }
        //自始至终都是子类对象做着类型的变化。


    }
}
</code></pre><h2 id="4-top-a-name-duotaitest2-">4. <a href="#top">分三个阶段 完成笔记本电脑使用外围设备。并通过接口解耦，并通过多态提高程序的扩展性。★★★★★★★</a><a name="DuoTaiTest2"/></h2>
<pre><code>
/*
阶段一需求：笔记本电脑运行。
按照面向对象的思想，用代码体现。
名称提炼法。
笔记本电脑。
    行为：运行。

class NoteBook
{
    //运行功能。
    public void run()
    {
        System.out.println(&quot;notebook run&quot;);
    }
}

阶段二需求：想要在笔记本电脑上加上一个手握式鼠标。
多了个对象：鼠标。
        行为：开启，关闭。
class Mouse
{
    public void open()
    {
        System.out.println(&quot;mouse open&quot;);
    }
    public void close()
    {
        System.out.println(&quot;mouse close&quot;);
    }
}
笔记本怎么用鼠标呢？
在笔记本中多一个使用鼠标的功能。
需要修改原来的笔记本类中的内容，添加一个功能。
class NoteBook
{
    //运行功能。
    public void run()
    {
        System.out.println(&quot;notebook run&quot;);
    }
    // 使用鼠标功能。
    public void useMouse(Mouse m)
    {
        if(m!=null)
        {
            m.open();
            m.close();
        }
    }
}
//问题：如果想要加入一个键盘呢？
只要描述一个键盘类，并在电脑类中加入一个使用键盘的功能就哦了。
但是发现从鼠标开始这个问题就已经产生了，一旦需要添加新设备的时候，
都需要改变电脑的源码。这个扩展性是非常差的。

设计上该如何改进呢？
之前的问题在于外围设备的增加和笔记本电脑之间的耦合性过高。
如何降低外围设备和笔记本电脑的耦合性呢？
外围设备还不确定，我们不要面对外围具体设备。
为了让笔记本可以使用这些设备，可以事先定义好一些规则，
笔记本只要使用这些规则就可以了。
有了这些规则就可以进行笔记本的功能扩展。
后期这些外围设备只要符合这些规则就可以被笔记本使用了。

那么规则在java中该如何体现呢？接口。

//1,描述接口。USB。

//2,描述笔记本电脑:运行功能，使用USB接口的功能。



*/
//USB接口定义。
interface USB
{
    void open();
    void close();
}

//描述笔记本电脑。 
class NoteBook
{
    public void run()
    {
        System.out.println(&quot;notebook run&quot;);
    }

    //使用usb接口的功能。
    public void useUSB(USB usb)//接口类型的变量。接口类型的变量指向自己的子类对象。
                                //USB usb = new Mouse();
    {
        if(usb!=null)
        {
            usb.open();
            usb.close();
        }
    }
}
//需要鼠标 。想要被笔记本电脑使用，该鼠标必须符合规则。
//描述鼠标。
class Mouse implements USB
{
    public void open()
    {
        System.out.println(&quot;mouse open&quot;);
    }
    public void close()
    {
        System.out.println(&quot;mouse close&quot;);
    }
}

class KeyBoard implements USB
{
    public void open()
    {
        System.out.println(&quot;KeyBoard open&quot;);
    }
    public void close()
    {
        System.out.println(&quot;KeyBoard close&quot;);
    }
}

/*
发现，接口的出现，
1，扩展了笔记本电脑功能。
2，定义了规则。
3，降低了笔记本电脑和外围设备之间的耦合性。
*/

class DuoTaiTest2 
{
    public static void main(String[] args) 
    {
        NoteBook book = new NoteBook();
        book.run();
        book.useUSB(null);
        book.useUSB(new Mouse());
        book.useUSB(new KeyBoard());
    }
}
</code></pre><h2 id="5-top-a-name-duotaidemo3-">5. <a href="#top">多态调用时，成员变量，成员函数，静态函数的特点。以及规律</a><a name="DuoTaiDemo3"/></h2>
<pre><code>
/*
多态中，成员调用的特点。

1，成员变量。
    当子父类中出现同名的成员变量时。
        多态调用该变量时：
            编译时期：参考的是引用型变量所属的类中是否有被调用的成员变量。没有，编译失败。
            运行时期：也是调用引用型变量所属的类中的成员变量。
        简单记：编译和运行都参考等号的左边。
                编译运行看左边。

2，成员函数。
    编译，参考左边，如果没有，编译失败。
    运行，参考右边的对象所属的类。
        编译看左边，运行看右边。

    对于成员函数是动态绑定到对象上。

3，静态函数。
    编译和运行都参考左边。

    静态函数是静态的绑定到类上。


【结论】
对于成员变量和静态函数，编译和运行都看左边。
对于成员函数，编译看左边，运行看右边。


*/
class Fu
{
    int num = 3;

    void show()
    {
        System.out.println(&quot;fu show run&quot;);
    }
    static void method()
    {
        System.out.println(&quot;fu static method run&quot;);
    }
}
class Zi extends Fu
{
    int num = 5;

    void show()
    {
        System.out.println(&quot;zi show run..&quot;);
    }
    static void method()
    {
        System.out.println(&quot;zi static method run&quot;);
    }
}



class DuoTaiDemo3 
{
    public static void main(String[] args) 
    {
        /*
        //测试成员变量的多态调用。
        Fu f = new Zi();
        System.out.println(f.num);//3
        Zi z = new Zi();
        System.out.println(z.num);//5
        */
        /*
        //测试成员函数的多态调用。
        Fu f = new Zi();
        f.show();
        */
        //测试静态函数的多态调用。
        Fu f = new Zi();
        f.method();
        //注意：真正开发静态方法是不会被多态调用的，因为静态方法不所属于对象，而是所属于类。
        Fu.method();
        Zi.method();
    }
}
</code></pre><h2 id="6-top-a-name-duotaitest3-">6. <a href="#top"> 一定要画图，得出结果。有点难！没视频，★★★★★</a><a name="DuoTaiTest3"/></h2>
<pre><code>//练习:看程序画图，得出结果！
class Fu
{
    int x = 4;
    Fu()
    {
        System.out.println(&quot;A fu() : &quot;+this.getNum());
    }
    int getNum()
    {
        System.out.println(&quot;B fu getnum run....&quot;+x);
        return 100;
    }
}
class Zi extends Fu
{
    int x = 5;
    Zi()
    {
        System.out.println(&quot;C zi() : &quot;+getNum());
    }
    int getNum()
    {
        System.out.println(&quot;D zi getnum run....&quot;+x);
        return 200;
    }
}
class DuoTaiTest3 
{
    public static void main(String[] args) 
    {
        Fu f = new Zi();
        //System.out.println(&quot;main :&quot; +f.getNum());
        //Person p = new Person(20):
    }
}
</code></pre><h2 id="7-object-equals-tostring-top-a-name-objectdemo-">7. <a href="#top">了解Object类中的equals toString方法的使用</a><a name="ObjectDemo"/></h2>
<pre><code>
/*
Object类中的常用方法。

Object类是所有类的根类，定义了所有对象都具备的功能。
API(应用程序接口)文档

*/
class Person extends Object
{
    private int age;
    Person(int age)
    {
        this.age = age;
    }
    //判断是否是同龄人。这个方法也是在比较两个person对象是否相等。
    //注意：Person类中是否有比较两个Person对象相等的方法？有的！因为继承Object，它本身就具备着equals方法。
    //既然有，还需要定义compare方法吗？不需要。
    //但是，equals方法判断的是地址，不是我们所需要的内容。
    //咋办？继续使用Object的equals方法，但是建立子类的自己的内容。传说中的重写。
    //重写。
//    【记住：以后判断对象是否相同，就需要覆盖equals方法。】
    public boolean equals(Object obj)
    {

        //建立Person自己的判断相同的依据。判断年龄是否相同。
//        return this.age == obj.age;//obj所属类型Object，Object中没有定义age，所以编译失败。

        //如果调用该方法的对象和传递进来的对象是同一个。就不要转型和判断，直接返回true。效率高一点。
        if(this == obj)
            return true;

        //age是Person类型的属性。既然要用到子类型的内容，需要向下转型。
        if(!(obj instanceof Person))
//            return false;
            throw new ClassCastException(&quot;类型是不对的！请改正。&quot;);
        Person p = (Person)obj;

        return this.age == p.age;

    }

    //覆盖toString方法，建立Person对象自己的字符串表现形式。
    public String toString()
    {
        return &quot;Person[age = &quot;+age+&quot;]&quot;;
    }

    /*
    public boolean compare(Person p)
    {
        return this.age == p.age;
    }
    */
}

class Dog
{
}

class ObjectDemo 
{
    public static void main(String[] args) 
    {
        Person p1 = new Person(12);
        Person p2 = new Person(15);
//        System.out.println(p1.equals(p2));

        System.out.println(p1.toString());//Person@da4b71//想要建立自定义对象的字符串表现实行。咋办、覆盖toString方法就哦了。
        System.out.println(p2);



//        -----------------------------
//        System.out.println(p1.compare(p2));
//        System.out.println(p1 == p2);
//        System.out.println(p1.equals(p2));
    }
}
</code></pre>
</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
