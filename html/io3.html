<!DOCTYPE html>
<html>
<head>
<title>MarkdownPad Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
</head>
<body>
<h1 id="io-3-">IO流（3）</h1>
<p><a name="top" /></p>
<h2 id="-">引言</h2>
<blockquote>
<p>早上已经完成IO流的相对应的练习，主要是IO流对电脑文件相对应的操作，FileInputStream和FileOutputStream的练习，接下来继续IO流，但主要会有点变化，接下来的是字符流综合使用</p>
</blockquote>
<ol>
<li><a href="#CharStreamDemo">一篇文章中出现了多少个好字。读取数据，使用了字符流FileReader</a></li><li><a href="#FileWriterDemo">演示FileWriter</a></li><li><a href="#TransStreamDemo">演示转换流，和子类的区别五星</a></li><li><a href="#CharStreamBufferedTest">字符流缓冲区对象的使用</a></li><li><a href="#CopyTextFileTest">通过字符流复制文件</a></li><li><a href="#FileFilterBySuffix">文件后缀名过滤器</a></li><li><a href="#SeparatorTool">分隔符工具类</a></li><li><a href="#Test2">请删除一个带有内容的目录</a></li><li><a href="#test4">将学生对象(姓名，语文分数，数学分数，英语分数，总分)按照总分从高到低排序五星并将姓名和从高到低总分写入文件中</a></li><li><a href="#Test5">建立一个java文件清单列表</a></li></ol>
<h2 id="-student-java">公共类Student.java</h2>
<pre><code>package cn.itcast.domain;

public class Student implements Comparable&lt;Student&gt;{

    private String name;
    private int cn,en,ma;
    private int sum;
    public Student() {
        super();
    }
    public Student(String name, int cn, int en, int ma) {
        super();
        this.name = name;
        this.cn = cn;
        this.en = en;
        this.ma = ma;
        this.sum = cn + en + ma;

    }



    @Override
    public int compareTo(Student o) {
        int temp = this.sum - o.sum;

        return temp==0?this.name.compareTo(o.name):temp;
    }
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + cn;
        result = prime * result + sum;
        return result;
    }
    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Student other = (Student) obj;
        if (cn != other.cn)
            return false;
        if (sum != other.sum)
            return false;
        return true;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getCn() {
        return cn;
    }

    public void setCn(int cn) {
        this.cn = cn;
    }
    public int getEn() {
        return en;
    }
    public void setEn(int en) {
        this.en = en;
    }
    public int getMa() {
        return ma;
    }
    public void setMa(int ma) {
        this.ma = ma;
    }
    public int getSum() {
        return sum;
    }
    public void setSum(int sum) {
        this.sum = sum;
    }



    @Override
    public String toString() {
        return &quot;Student [name=&quot; + name + &quot;, sum=&quot; + sum + &quot;]&quot;;
    }


}
</code></pre><h2 id="-filereader-top-a-name-charstreamdemo-"><a href="#top">一篇文章中出现了多少个好字。读取数据，使用了字符流FileReader</a><a name="CharStreamDemo"/></h2>
<pre><code>package cn.itcast.io.a.charstream;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;

public class CharStreamDemo {

    /**
     * @param args
     * @throws IOException 
     */
    public static void main(String[] args) throws IOException {

        /*
         * 需求1：通过流写一个篇文章，里面有中文。&quot;你好你好&quot;。indexOf(&#39;好&#39;);
         */
//        writeCNText();


        /*
         * 需求2：一篇文章中出现了多少个好字。读取数据。判断好字并计数。
         * 思路：读取一个文本，获取内容判断好字。
         */

         readCNText();

        /*
         * 解决需求2问题：
         * 使用FileReader。
         * 
         */
         System.out.println(&quot;-----------读取字符-------------&quot;);
        readCNTextByReader();

    }

    public static void readCNTextByReader() throws IOException {

        //创建一个读取字符文件的读取流对象。FileReader。
        FileReader fr = new FileReader(&quot;tempfile\\cn.txt&quot;);//这个流的底层使用的是FileInputStream

//        int ch = fr.read();
//        System.out.println(&quot;读取一个字符：&quot;+ch);
//        int ch1 = fr.read();//一次读取一个中文，读取多个字节查表转成中文。
//        System.out.println(&quot;读取一个字符：&quot;+(char)ch1);
        int ch = 0;
        int count = 0;
        while((ch=fr.read())!=-1){
            if(ch==&#39;好&#39;){
                count++;
            }
        }
        System.out.println(&quot;count=&quot;+count);
        fr.close();
    }

    public static void readCNText() throws IOException {
        FileInputStream fis = new FileInputStream(&quot;tempfile\\cn.txt&quot;);

        //一次读一个字节。这样对中文是无法判断。怎么解决呢？一个中文默认是两个字节。
        //读取所有的字节，存储起来(字节数组)，变成字符串。然后找指定的字符。

//        byte[] buf = new byte[4];
//        int len = 0;
//        while((len=fis.read(buf))!=-1){
//            String str = new String(buf,0,len);
//            System.out.println(str);
//        }

//        int ch = 0;
//        while((ch=fis.read())!=-1){
//            System.out.println(ch);
//        }

        int ch = fis.read();
        System.out.println(&quot;读取一个字节：&quot;+ch);
        int ch1 = fis.read();
        System.out.println(&quot;读取一个字节：&quot;+ch1);
        fis.close();

    }

    public static void writeCNText() throws FileNotFoundException, IOException {
        FileOutputStream fos = new FileOutputStream(&quot;tempfile\\cn.txt&quot;);

        fos.write(&quot;你好你好&quot;.getBytes());

        fos.close();
    }

}
</code></pre><h2 id="-filewriter-top-a-name-filewriterdemo-"><a href="#top">演示FileWriter</a><a name="FileWriterDemo"/></h2>
<pre><code>package cn.itcast.io.a.charstream;

import java.io.FileWriter;
import java.io.IOException;

public class FileWriterDemo {

    /**
     * @param args
     * @throws IOException 
     */
    public static void main(String[] args) throws IOException {
        //演示FileWriter 用于操作文件的便捷类。
        FileWriter fw = new FileWriter(&quot;tempfile\\fw.txt&quot;);

        fw.write(&quot;你好谢谢再见&quot;);//这些文字都要先编码。都写入到了流的缓冲区中。

        fw.flush();

        fw.close();

        /*
         * flush()和close()的区别？
         * 
         * flush():将流中的缓冲区缓冲的数据刷新到目的地中，刷新后，流还可以继续使用。
         * close():关闭资源，但在关闭前会将缓冲区中的数据先刷新到目的地，否则丢失数据，然后在关闭流。流不可以使用。
         * 
         * 如果写入数据多，一定要一边写一边刷新，最后一次可以不刷新，由close完成刷新并关闭。
         * 
         * 
         */
    }

}


//public void close(){
//    flush();
//}
</code></pre><h2 id="-top-a-name-transstreamdemo-"><a href="#top">演示转换流，和子类的区别五星</a><a name="TransStreamDemo"/></h2>
<pre><code>package cn.itcast.io.b.transstream;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;

public class TransStreamDemo {

    /**
     * @param args
     * @throws IOException 
     * @throws UnsupportedEncodingException 
     */
    public static void main(String[] args) throws Exception {

//        writeCN();

        readCN();
        /*
        总结：
        发现继承关系是这样的。
        OutputStreamWriter:
            |--FileWriter:

        InputStreamReader:
            |--FileReader;

        父类和子类的功能有什么区别呢？

        OutputStreamWriter和InputStreamReader是字符和字节的桥梁：也可以称之为字符转换流。
        字符转换流原理：字节流+编码表。

        FileWriter和FileReader：作为子类，仅作为操作字符文件的便捷类存在。
        当操作的字符文件，使用的是默认编码表时可以不用父类，而直接用子类就完成操作了，简化了代码。

        InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;a.txt&quot;));//默认字符集。
        InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;a.txt&quot;),&quot;GBK&quot;);//指定GBK字符集。
        FileReader fr = new FileReader(&quot;a.txt&quot;);
        这三句代码的功能是一样的，其中第三句最为便捷。

        注意：一旦要指定其他编码时，绝对不能用子类，必须使用字符转换流。
        什么时候用子类呢？
        条件：
        1，操作的是文件。
        2，使用默认编码。

        字节---&gt;字符 ： 看不懂的---&gt;看的懂的。  需要读。输入流。 InputStreamReader
        字符---&gt;字节 ： 看的懂的---&gt;看不懂的。  需要写。输出流。 OutputStreamWriter


        */
    }

    public static void readCN() throws IOException {

        //创建InputStreamReader对象。
        InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;tempfile\\u8cn.txt&quot;),&quot;UTF-8&quot;);

        char[] buf = new char[1024];
        int len = isr.read(buf);
        System.out.println(new String(buf,0,len));
        isr.close();
    }

    //读取中文。
    public static void readCN_no() throws IOException {

        // 使用FileReader没出来，因为文件是UTF-8编码。读取UTF-8字节时，用该指定用UTF-8解码。
        // 说明需要指定码表。那就需要使用InputStreamReader。
        FileReader fr = new FileReader(&quot;tempfile\\u8cn.txt&quot;);
//        int ch = (char)fr.read();
//        System.out.println((char)ch);
        char[] buf = new char[1024];
        int len = fr.read(buf);
        System.out.println(new String(buf,0,len));//浣犲ソ


        fr.close();

    }

    public static void writeCN() throws Exception {
        //需求：既然识别中文的码表有两个，GBK UTF-8
        //能不能将中文数据按照utf-8的方式进行文件的存储呢？
        //还能使用FileWriter吗？不能使用了，因为FileWriter中默认的是GBK
        //通过FileWriter的api描述，要指定编码表这些值，需要使用OutputStreamWriter 
        //OutputStreamWriter 是字符流通向字节流的桥梁：可使用指定的 charset 将要写入流中的字符编码成字节。
        //它的作用的就是，将字符串按照指定的编码表转成字节，在使用字节流将这些字节写出去。

        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;tempfile\\u8cn.txt&quot;),&quot;utf-8&quot;);

        osw.write(&quot;你好&quot;);//写入缓冲区。

        osw.close();
    }

}
</code></pre><h2 id="-top-a-name-charstreambufferedtest-"><a href="#top">字符流缓冲区对象的使用</a><a name="CharStreamBufferedTest"/></h2>
<pre><code>package cn.itcast.io.c.charstream.buffercopy;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class CharStreamBufferedTest {

    /**
     * @param args
     * @throws IOException 
     */
    public static void main(String[] args) throws IOException {
        /*
         * 字符流中是否有提供缓冲区中。
         * 注意：其实自定义数组就可以解决问题缓冲区问题并提高效率。
         * 为什么还要使用流中的缓冲区对象呢？因为缓冲区对象中除了封装数组以外，
         * 还提供了更多的操作缓冲区数据的方法。
         * BufferedReader  BufferedWriter
         * 
         * 讲解字符流缓冲区中的特有方法。
         * 操作字符数据时，有一个文本特有的表形实行 ：行(hang)
         * 操作行的方法。
         * BufferedReader:readLine():一次读取一行。
         * BufferedWriter:
         */

        copyTextByBuffer();
//        readText();

//        writeText();
    }

    public static void writeText() throws IOException {
        BufferedWriter bufw = new BufferedWriter(new FileWriter(&quot;tempfile\\test24_buf.txt&quot;));

        for(int x=1; x&lt;=4; x++){
            bufw.write(x+&quot;-itcast&quot;);
            bufw.newLine();
            bufw.flush();
        }
        bufw.close();
    }

    public static void readText() throws IOException {

        BufferedReader bufr = new BufferedReader(new FileReader(&quot;Test24.java&quot;));


        String line = null;
        while((line=bufr.readLine())!=null){

            System.out.println(line);

        }

//        String line = bufr.readLine();
//        System.out.println(&quot;-&quot;+line+&quot;-&quot;);
//        String line1 = bufr.readLine();
//        System.out.println(&quot;-&quot;+line1+&quot;-&quot;);

        bufr.close();


    }

    public static void copyTextByBuffer() throws IOException {

        BufferedReader bufr = new BufferedReader(new FileReader(&quot;Test24.java&quot;));
        BufferedWriter bufw = new BufferedWriter(new FileWriter(&quot;tempfile\\test24_bufcopy.txt&quot;));

        //循环读写一行数据。
        String line = null;
        while((line=bufr.readLine())!=null){
            bufw.write(line);
            bufw.newLine();
            bufw.flush();
        }

        bufw.close();
        bufr.close();

    }

}
</code></pre><h2 id="-top-a-name-copytextfiletest-"><a href="#top">通过字符流复制文件</a><a name="CopyTextFileTest"/></h2>
<pre><code>package cn.itcast.io.c.charstream.copy;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class CopyTextFileTest {

    /**
     * @param args
     * @throws IOException 
     */
    public static void main(String[] args) throws IOException {
        /*
         * 练习：复制文本文件。
         * 思路：
         * 1，既然是文本涉及编码表。需要用字符流。
         * 2，操作的是文件。涉及硬盘。
         * 3，有指定码表吗？没有，默认就行。
         * 操作的是文件，使用的 默认码表。使用哪个字符流对象。直接使用字符流操作文件的便捷类。FileReader  FileWriter
         */
        copyTextFile();
    }

    public static void copyTextFile() throws IOException {
        //1,明确源和目的。
        FileReader fr = new FileReader(&quot;Test24.java&quot;);
        FileWriter fw = new FileWriter(&quot;tempfile\\test24_copy.txt&quot;);

        //2,为了提高效率。自定义缓冲区数组。字符数组。
        char[] buf = new char[1024];

        int len = 0;
        while((len=fr.read(buf))!=-1){
            fw.write(buf,0,len);
        }


        //2,循环读写操作。效率低。
//        int ch = 0;
//        while((ch=fr.read())!=-1){
//            fw.write(ch);
//        }


        //3,关闭资源。
        fw.close();
        fr.close();

    }

}
</code></pre><h2 id="-top-a-name-filefilterbysuffix-"><a href="#top">文件后缀名过滤器</a><a name="FileFilterBySuffix"></h2>
<pre><code>package cn.itcast.io.test;

import java.io.File;
import java.io.FileFilter;

public class FileFilterBySuffix implements FileFilter {

    private String suffix;

    public FileFilterBySuffix(String suffix) {
        super();
        this.suffix = suffix;
    }

    @Override
    public boolean accept(File pathname) {

        return pathname.getName().endsWith(suffix);
    }

}
</code></pre><h2 id="-a-name-separatortool-">[分隔符工具类]<a name="SeparatorTool"/></h2>
<pre><code>package cn.itcast.io.test;

/**
 * 为了避免总是调用System.getProperties(&quot;系统属性中的指定键&quot;);
 * 进行了封装。下次再使用分隔符，直接找个分隔符工具类就哦了。
 * @author Teaching
 *
 */
public class SeparatorTool {


    private  SeparatorTool() {
        super();
    }
    public static final String LINE_SEPARATOR = System.getProperty(&quot;line.separator&quot;);
    public static final String PATH_SEPARATOR = System.getProperty(&quot;path.separator&quot;);
    public static final String FILE_SEPARATOR = System.getProperty(&quot;file.separator&quot;);


}
</code></pre><h2 id="-top-a-name-test2-"><a href="#top">请删除一个带有内容的目录</a><a name="Test2"/></h2>
<pre><code>package cn.itcast.io.test;

import java.io.File;

public class Test2 {

    /**
     * @param args
     */
    public static void main(String[] args) {
        // 2，请删除一个带有内容的目录。
        /*
         * 思路: 1，删除一个带有内容的目录原理；必须从里往外删。 2，到底有多级目录不确定，递归。
         */
        File dir = new File(&quot;E:\\test&quot;);

        // System.out.println(dir.delete());

        removeDir(dir);

    }

    /**
     * 删除一个目录。
     */
    public static void removeDir(File dir) {

        // 1,列出当前目录下的文件以及文件夹File[]
        File[] files = dir.listFiles();//如果目录是系统级文件夹，java没有访问权限，那么会返回null数组。最好加入判断。
        if (files != null) {
            // if(files.length == 0){
            // dir.delete();
            // return;
            // }

            for (File file : files) {

                // 2,对遍历到的file对象判断是否是目录。
                if (file.isDirectory()) {
                    removeDir(file);
                } else {
                    System.out.println(file + &quot;:&quot; + file.delete());// 删除文件。用打印语句验证是否删除成功，是否出现了误删操作。
                }
            }
        }
        System.out.println(dir + &quot;:&quot; + dir.delete());

    }
}
</code></pre><h2 id="-top-a-name-test4-"><a href="#top">将学生对象(姓名，语文分数，数学分数，英语分数，总分)按照总分从高到低排序五星并将姓名和从高到低总分写入文件中</a><a name="test4"/></h2>
<pre><code>package cn.itcast.io.test;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Collections;
import java.util.Set;
import java.util.TreeSet;

import cn.itcast.domain.Student;

public class Test4 {

    private static final String LINE_SEPARATOR = System.getProperty(&quot;line.separator&quot;);

    /**
     * @param args
     * @throws IOException 
     */
    public static void main(String[] args) throws IOException {
//        4，将学生对象(姓名，语文分数，数学分数，英语分数，总分)按照总分从高到低排序，
//        并将姓名和从高到低总分写入文件中。
        /*
         * 思路：
         * 1，描述学生。
         * 2，既然要按照总分从高到低排序，学生多要存储集合，TreeSet。
         * 3，将信息具体的信息保存到文件中。
         *         操作文件,持久化存储，涉及了IO技术。而且是将数据存储到文件中。所以写入。输出流。
         * 
         */
        Set&lt;Student&gt; set = new TreeSet&lt;Student&gt;(Collections.reverseOrder());

        set.add(new Student(&quot;李四&quot;,20,20,20));
        set.add(new Student(&quot;旺财&quot;,10,10,20));
        set.add(new Student(&quot;小明&quot;,60,30,70));
        set.add(new Student(&quot;小红&quot;,80,90,80));
        set.add(new Student(&quot;小强&quot;,20,70,20));

        File dir = new File(&quot;tempfile&quot;);
        if(!dir.exists()){
            dir.mkdir();
        }
        File destFile = new File(dir,&quot;student_info.txt&quot;);
        write2File(set,destFile);




    }

    public static void write2File(Set&lt;Student&gt; set, File destFile) throws IOException {

        //1, 创建输出流对象和目的文件关联。并创建目的文件。OutputStream操作文件 FileOutputStream。
        FileOutputStream fos = null;
        try{
            fos = new FileOutputStream(destFile);
            //2,遍历集合中的对象数据。将数据写入到指定文件中。

            for(Student stu : set){
                String info = stu.getName()+&quot;\t&quot;+stu.getSum()+LINE_SEPARATOR;
                //3,将数据写入到文件中。
                fos.write(info.getBytes());
            }
        }finally{
            if(fos!=null){

                //关闭资源。
                try {
                    fos.close();
                } catch (IOException e) {
                    throw new RuntimeException(&quot;系统资源关闭失败&quot;);
                }
            }
        }

    }

}
</code></pre><h2 id="-java-top-a-name-test5-"><a href="#top">建立一个java文件清单列表</a><a name="Test5"/></h2>
<pre><code>package cn.itcast.io.test;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class Test5 {

    private static final String LINE_SEPARATOR = SeparatorTool.LINE_SEPARATOR;

    /**
     * @param args
     * @throws IOException 
     */
    public static void main(String[] args) throws IOException {
//        5，获取指定目录下所有的.java文件(包含子目录中的)，
//        并将这些java文件的绝路路径写入到一个文件中。
//        建立一个java文件清单列表。
        /*
         * 思路：
         * 1，一看到包含子目录，必须递归。
         * 2，写数据到文件，输出流。
         * 3，继续分析，发现只要.java ，需要过滤器。
         * 4，满足过滤的条件的文件有可能非常多，先进行存储。
         */
        //被遍历的目录。
        File dir = new File(&quot;E:\\Java_Code&quot;);

        //明确一个过滤器。
        FileFilter filter = new FileFilterBySuffix(&quot;.java&quot;);


        //符合过滤器条件的文件有很多，最好先存储起来，然后在进行操作。
        List&lt;File&gt; list = new ArrayList&lt;File&gt;();
        //获取指定文件清单。
        getFileList(dir,filter,list);
//        System.out.println(list.size());

        File destFile = new File(dir,&quot;javalist.txt&quot;);
        write2File(list,destFile);
    }

    /**
     * 将集合中的数据的绝对路径写入到文件中。
     * @param list
     * @param destFile
     * @throws IOException 
     */
    public static void write2File(List&lt;File&gt; list, File destFile) throws IOException {
        FileOutputStream fos = null;
        BufferedOutputStream bufos = null;
        try{
            fos = new FileOutputStream(destFile);
            bufos = new BufferedOutputStream(fos);

            for(File file : list){
                String info = file.getAbsolutePath()+LINE_SEPARATOR;
                bufos.write(info.getBytes());
                bufos.flush();//每写一个绝对路径就刷新一次。
            }
        }finally{
            if(bufos!=null){
                try {
                    fos.close();
                } catch (IOException e) {
                    throw new RuntimeException(&quot;关闭失败&quot;);
                }
            }
        }

    }

    /**
     * 根据指定的过滤器在指定目录下获取所有的符合过滤条件的文件，并存储到list集合中。
     * @param dir
     * @param filter
     * @param list
     */
    public static void getFileList(File dir,FileFilter filter,List&lt;File&gt; list) {

        File[] files = dir.listFiles();

        for(File file : files){

            if(file.isDirectory()){
                getFileList(file,filter,list);
            }else{
                //如果是文件，传递到过滤器中去过滤。将满足条件存储起来。
                if(filter.accept(file)){
                    list.add(file);
                }
            }
        }

    }


}
</code></pre>
</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
